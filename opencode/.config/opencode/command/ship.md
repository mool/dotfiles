---
description: Validate, commit, and create a draft PR with proper hygiene checks
---

# /ship Command

You are helping the user create a well-formed pull request. This command validates changes, ensures atomic commits, and creates a draft PR with a complete description.

---

## Workflow Steps

### Step 1: Gather Context

```bash
# Get GitHub username for branch naming
gh api user --jq '.login'

# Check current branch and status
git branch --show-current
git status --porcelain

# Get base branch (default: main)
git remote show origin | grep 'HEAD branch' | awk '{print $NF}'

# Check for uncommitted changes
git diff --stat
git diff --cached --stat

# Review commit history on this branch vs main
git log main..HEAD --oneline
git diff main...HEAD --stat
```

### Step 2: Validate Branch Name

Branch should follow pattern: `IP-<number>-<description>`

Extract the Jira ticket number (IP-####). If not found in branch name:

- **ASK the user** for the Jira ticket number

You can ask the @atlassian agent or use the Jira MCP to validate the ticket and get more context about it (e.g., title, description, status) to include in the PR description.

### Step 3: Pre-Flight Hygiene Checks

Run these checks and report findings. **Ask the user** how to handle each issue found.

#### 3.1 PR Size Check

```bash
git diff main...HEAD --stat | tail -1
```

- If changes exceed **600 lines**: Flag as issue, suggest splitting PR

#### 3.2 Environment Safety Check

Look for changes that affect multiple environments simultaneously:

- Changes in both `dev/` and `prod/` directories
- Changes in both `stage/` and `prod/` directories
- Config changes without environment scoping

#### 3.3 Debug Statement Detection

Search for common debug patterns:

```bash
git diff main...HEAD | grep -E '^\+.*((console\.(log|debug|warn|error))|(print\()|debugger|binding\.pry|byebug|pdb\.set_trace|var_dump|dd\()'
```

#### 3.4 TODO/FIXME Detection

```bash
git diff main...HEAD | grep -E '^\+.*(TODO|FIXME|HACK|XXX|BUG):'
```

#### 3.5 Secrets Detection

```bash
git diff main...HEAD | grep -iE '^\+.*(password|secret|api_key|apikey|token|credential|private_key).*=.*["\047]'
git diff main...HEAD --name-only | grep -iE '\.(env|pem|key|secrets?)$'
```

#### 3.6 Conflict Markers

```bash
git diff main...HEAD | grep -E '^\+.*(<<<<<<<|=======|>>>>>>>)'
```

#### 3.7 Large File Detection

```bash
git diff main...HEAD --stat | awk '$3 > 500 {print "Large file:", $1, "("$3" lines)"}'
```

#### 3.8 LLM-ism Detection

Look for patterns that suggest AI-generated comments that should be removed:

- Obvious/redundant comments that just restate the code
- "Here's" phrasing (e.g., "Here's the implementation")
- AI attribution markers (e.g., "#AI-generated", "// Generated by")
- Excessive "Note:" or "Important:" prefixes
- Transient implementation details that will be stale in days
  - e.g., "Set to dev for migration in IP-1234" for a 1-2 day migration

**Philosophy**: Code should be self-documenting. Comments should only exist for genuinely tricky/non-obvious logic that will remain relevant for months.

```bash
git diff main...HEAD | grep -iE '^\+\s*(#|//|/\*|\*).*((here.?s (the|a|an|my))|AI.?generated|generated by|note:|important:)'
```

#### 3.9 README Check

If significant changes are made to public APIs or features:

```bash
git diff main...HEAD --name-only
```

Remind user to consider if README needs updating.

### Step 4: Review Commits for Atomicity

```bash
git log main..HEAD --oneline
git log main..HEAD --format='%s'
```

Check for non-atomic commit patterns:

- "WIP" commits
- "fix typo" or "oops" commits
- Multiple unrelated changes in commit messages
- Very small fixup commits that should be squashed

If issues found, **suggest cleanup options**:

- Interactive rebase to squash/reword
- Soft reset and recommit atomically

### Step 5: Optional Platform Review

Ask the user:

> "Would you like to run @platform-review before creating the PR? (yes/no)"

If yes, invoke the platform-review agent.

### Step 6: Stage and Commit (if needed)

If there are uncommitted changes:

1. Show the diff and confirm what should be committed
2. Create commit with proper message format:

```
<type>(IP-####): <description>

<optional body with more context>
```

Types: `feat`, `fix`, `docs`, `refactor`, `perf`, `test`, `ci`, `chore`

### Step 7: Push to Remote

Push with upstream tracking:

```bash
git push -u origin HEAD
```

### Step 8: Create Draft PR

If the repo has a default PR template, use it to pre-fill the body. Otherwise,
build the PR with this structure:

```markdown
## Summary

<High-level summary of what this PR accomplishes - 2-4 sentences>

## Changes

<Key implementation decisions with links to documentation>

- **<Decision 1>**: <explanation> ([docs link])
- **<Decision 2>**: <explanation> ([docs link])

## Notes

<Anything confusing or non-obvious in the diff>

- **<file:line>**: <why this looks weird but is correct> ([docs link if available])

---

**Jira**: <link to Jira ticket>
<Related GitHub issues if any, auto-detected from commits and context>
```

Before creating the PR, **ask the user** to confirm the title and body. Allow
them to edit the body if needed.

Create as **draft**:

```bash
gh pr create --draft --title "<type>(IP-####): <description>" --body "<body>"
```

**PR Title Format**: `<type>(IP-####): <short description>`

### Step 9: Confirm Success

Output:

- Link to the created PR
- Reminder that it's a draft
- Summary of what was included

---

## Validation Summary Checklist

Before creating the PR, summarize findings:

| Check                      | Status | Notes |
| -------------------------- | ------ | ----- |
| Branch has Jira ticket     |        |       |
| PR under 600 lines         |        |       |
| Environment promotion safe |        |       |
| No debug statements        |        |       |
| No TODOs (or acknowledged) |        |       |
| No secrets detected        |        |       |
| No conflict markers        |        |       |
| No oversized files         |        |       |
| No LLM-isms                |        |       |
| Tests exist for new code   |        |       |
| Commits are atomic         |        |       |

---

## Error Handling

- If any blocking issue is found, **stop and ask** before proceeding
- If push fails, check if branch exists remotely and advise
- If PR creation fails, show the error and suggest fixes
- Never force push without explicit user request

---

## Example Invocation

User: `/ship`

Agent:

1. Gathers context (branch, changes, commits)
2. Extracts/confirms Jira ticket: "I see IP-1234 in your branch. Is this correct?"
3. Runs hygiene checks, reports findings
4. Asks about any issues found
5. Asks about platform review
6. If uncommitted changes, creates commit
7. Pushes
8. Asks for PR title and body confirmation/editing
9. Drafts PR with complete body
10. Returns PR link
